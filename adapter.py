"""Governance Adapter for integrating with hyper-governance-core artifacts.

This module provides the integration layer between hyper-spec-core and
the governance artifacts generated by hyper-governance-core's codex weave command.
"""

from __future__ import annotations

import re
import sys
from dataclasses import dataclass, field
from pathlib import Path
from typing import TYPE_CHECKING

import yaml

if TYPE_CHECKING:
    pass


@dataclass
class GovernanceContext:
    """Strongly-typed container for parsed governance rules.

    Attributes:
        allowed_libs: List of libraries permitted by governance policy.
        banned_libs: List of libraries forbidden by governance policy.
        security_controls: Extracted security control text from security.md.
        architectural_layers: Extracted architectural layer text from architecture.md.
    """

    allowed_libs: list[str] = field(default_factory=list)
    banned_libs: list[str] = field(default_factory=list)
    security_controls: str = ""
    architectural_layers: str = ""

    def to_system_prompt(self) -> str:
        """Format governance context for LLM system prompt injection.

        Returns:
            Formatted string suitable for inclusion in an LLM system prompt.
        """
        allowed = ", ".join(self.allowed_libs) if self.allowed_libs else "None specified"
        banned = ", ".join(self.banned_libs) if self.banned_libs else "None specified"

        sections = [
            "GOVERNANCE CONSTRAINTS (NON-NEGOTIABLE):",
            "",
            "[TECHNOLOGY STACK]",
            f"Allowed Libraries: {allowed}",
            f"Banned Libraries: {banned}",
        ]

        if self.security_controls:
            sections.extend(["", "[SECURITY CONTROLS]", self.security_controls])

        if self.architectural_layers:
            sections.extend(["", "[ARCHITECTURAL LAYERS]", self.architectural_layers])

        return "\n".join(sections)


class GovernanceAdapter:
    """Adapter for loading and parsing governance artifacts from .codex directory.

    This class reads the artifacts generated by `codex weave` and transforms them
    into a format suitable for AI agent context injection.

    Args:
        governance_path: Path to the .codex directory containing governance artifacts.

    Raises:
        FileNotFoundError: If the governance artifacts directory doesn't exist
            or required files are missing.
    """

    STACK_FILE = "stack.yaml"
    SECURITY_FILE = "security.md"
    ARCHITECTURE_FILE = "architecture.md"

    def __init__(self, governance_path: Path) -> None:
        """Initialize the adapter with the path to governance artifacts.

        Args:
            governance_path: Path to the .codex directory.
        """
        self.governance_path = Path(governance_path)

    def load_context(self) -> GovernanceContext:
        """Load and parse all governance artifacts into a unified context.

        Returns:
            GovernanceContext containing parsed governance rules.

        Raises:
            FileNotFoundError: If the governance path or stack.yaml doesn't exist.
        """
        stack_path = self.governance_path / self.STACK_FILE

        if not self.governance_path.exists():
            raise FileNotFoundError(
                f"Governance artifacts not found at '{self.governance_path}'. "
                "Run 'codex weave' in the governance repo."
            )

        if not stack_path.exists():
            raise FileNotFoundError(
                f"Required artifact '{self.STACK_FILE}' not found at '{self.governance_path}'. "
                "Run 'codex weave' in the governance repo."
            )

        # Parse stack.yaml
        allowed_libs, banned_libs = self._parse_stack_yaml(stack_path)

        # Parse markdown files with graceful degradation
        security_controls = self._load_markdown_section(
            self.governance_path / self.SECURITY_FILE,
            "<!-- BEGIN_CONTROLS -->",
            "<!-- END_CONTROLS -->",
            "Security Controls",
        )

        architectural_layers = self._load_markdown_section(
            self.governance_path / self.ARCHITECTURE_FILE,
            "<!-- BEGIN_LAYERS -->",
            "<!-- END_LAYERS -->",
            "Architectural Layers",
        )

        return GovernanceContext(
            allowed_libs=allowed_libs,
            banned_libs=banned_libs,
            security_controls=security_controls,
            architectural_layers=architectural_layers,
        )

    def _parse_stack_yaml(self, stack_path: Path) -> tuple[list[str], list[str]]:
        """Parse stack.yaml to extract allowed and banned libraries.

        Supports two schema formats:
        1. Flat (actual codex weave output):
           allowed_libraries: [...]
           banned_libraries: [...]

        2. Nested (original spec format):
           rules:
             material:
               stack:
                 allowed_libraries: [...]
                 banned_libraries: [...]

        Args:
            stack_path: Path to the stack.yaml file.

        Returns:
            Tuple of (allowed_libraries, banned_libraries) lists.
        """
        with stack_path.open() as f:
            data = yaml.safe_load(f) or {}

        # Try flat format first (actual codex weave output)
        allowed = data.get("allowed_libraries")
        banned = data.get("banned_libraries")

        # Fall back to nested format if flat keys not found
        if allowed is None and banned is None:
            rules = data.get("rules", {})
            material = rules.get("material", {})
            stack = material.get("stack", {})
            allowed = stack.get("allowed_libraries")
            banned = stack.get("banned_libraries")

        # Ensure we return lists even if values are None
        return (
            allowed if isinstance(allowed, list) else [],
            banned if isinstance(banned, list) else [],
        )

    def _load_markdown_section(
        self,
        file_path: Path,
        start_tag: str,
        end_tag: str,
        section_name: str,
    ) -> str:
        """Load a markdown file and extract content between anchor tags.

        Args:
            file_path: Path to the markdown file.
            start_tag: Opening anchor tag (e.g., <!-- BEGIN_CONTROLS -->).
            end_tag: Closing anchor tag (e.g., <!-- END_CONTROLS -->).
            section_name: Human-readable name for warning messages.

        Returns:
            Extracted content between tags, or empty string if not found.
        """
        if not file_path.exists():
            print(
                f"Warning: Governance artifact '{file_path.name}' not found. "
                f"'{section_name}' will be empty.",
                file=sys.stderr,
            )
            return ""

        content = file_path.read_text()
        extracted = self._extract_section(content, start_tag, end_tag)

        if not extracted:
            print(
                f"Warning: Governance section '{section_name}' not found in "
                f"'{file_path.name}'. Check for anchor tags.",
                file=sys.stderr,
            )

        return extracted

    @staticmethod
    def _extract_section(content: str, start_tag: str, end_tag: str) -> str:
        """Extract content between anchor tags using regex.

        Args:
            content: Full file content.
            start_tag: Opening anchor tag.
            end_tag: Closing anchor tag.

        Returns:
            Content between tags (stripped), or empty string if not found.
        """
        # Escape special regex characters in tags
        start_escaped = re.escape(start_tag)
        end_escaped = re.escape(end_tag)

        pattern = rf"{start_escaped}\s*(.*?)\s*{end_escaped}"
        match = re.search(pattern, content, re.DOTALL)

        if match:
            return match.group(1).strip()

        return ""
